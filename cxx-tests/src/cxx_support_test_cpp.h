// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Build in test mode only to test cxx integration.

#ifndef CXX_SUPPORT_TEST_CPP
#define CXX_SUPPORT_TEST_CPP

#include <cstdint>
#include <memory>
#include <cstddef>
#include <new>
#include <type_traits>
#include <utility>

#include "moveit-cxx-tests/src/tests.rs.h"

// Test code status reporting

extern Status status;

inline Status get_status() {
  return status;
}

inline void set_status(Status new_status) {
  status = new_status;
}

inline void reset_status() {
  set_status(Status::Unallocated);
}

// Actual classes that would really be in production
// code

class Foo {
 public:
  Foo() {
    data[0] = 0;
    set_status(Status::Initialized);
  }
  bool get_a() const { return data[0] != 0; }
  void modify() { data[0] = 1; }
  ~Foo() {
    set_status(Status::Destructed);
  }
  // We test using a custom operator new/delete
  // pair partly for purposes of recording status,
  // and partly so that we can verify that moveit
  // will work for C++ classes which do similar.
  void* operator new(size_t count) {
    set_status(Status::Allocated);
    return ::operator new(count);
  }
  void* operator new(size_t count, void* ptr) {
    set_status(Status::Allocated);
    return ::operator new(count, ptr);
  }
  void operator delete(void* ptr) noexcept {
    ::operator delete(ptr);
    set_status(Status::Deallocated);
  }

 private:
  uint32_t data[4];
};

class Bar {
public:
  Bar() {
    data[0] = 0;
    set_status(Status::Initialized);
  }
  ~Bar() {
    set_status(Status::Destructed);
  }
  void do_nothing() const {}

private:
  uint32_t data[4];
};

// Everything below here would be generated by some code generator

// Mechanics to call custom deallocators

template<class T>
auto delete_imp(T* ptr, int) -> decltype(T::operator delete(ptr), void())
{
  T::operator delete(ptr);
}

template<class T>
auto delete_imp(T* ptr, long) -> decltype(::operator delete(ptr), void())
{
  ::operator delete(ptr);
}

template<class T>
auto delete_appropriately(T* obj) -> decltype(delete_imp(obj, 0), void())
{
  // 0 is a better match for the first 'delete_imp' so will match
  // preferentially.
  delete_imp(obj, 0);
}

template void delete_appropriately<Foo>(Foo*);
template void delete_appropriately<Bar>(Bar*);

inline Foo* foo_create_uninitialized() {
  std::allocator<Foo> alloc;
  set_status(Status::Allocated);
  return alloc.allocate(1);
}

inline void foo_free_uninitialized(Foo* foo) {
  set_status(Status::DeallocatedUninitialized);
  delete_appropriately<Foo>(foo);
  // This should end up calling operator delete
  // and replacing DeallocatedUninitialized with
  // Deallocated.
}

inline Bar* bar_create_uninitialized() {
  std::allocator<Bar> alloc;
  set_status(Status::Allocated);
  return alloc.allocate(1);
}

inline void bar_free_uninitialized(Bar* bar) {
  set_status(Status::DeallocatedUninitialized);
  delete_appropriately<Bar>(bar);
}

inline void foo_constructor(Foo& foo) { new (&foo) Foo(); }
inline void foo_destructor(Foo* foo) { foo->~Foo(); }
inline void foo_move(Foo* dest, Foo* src) {
  new (dest) Foo(std::move(*src));
}

inline void bar_constructor(Bar& bar) { new (&bar) Bar(); }
inline void bar_destructor(Bar* bar) { bar->~Bar(); }
inline void bar_move(Bar* dest, Bar* src) {
  new (dest) Bar(std::move(*src));
}

#endif  // CXX_SUPPORT_TEST_CPP