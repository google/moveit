// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Build in test mode only to test cxx integration.

#ifndef CXX_SUPPORT_TEST_CPP
#define CXX_SUPPORT_TEST_CPP

#include <cstddef>
#include <cstdint>
#include <memory>
#include <new>
#include <type_traits>
#include <utility>

#include "moveit-cxx-tests/src/tests.rs.h"
#include "new_helpers.h"

// Test code status reporting

extern Status status;

inline Status GetStatus() { return status; }

inline void SetStatus(Status new_status) { status = new_status; }

inline void ResetStatus() { SetStatus(Status::Unallocated); }

// Actual classes that would really be in production
// code

class Foo {
public:
  Foo() {
    data[0] = 0;
    SetStatus(Status::Initialized);
  }
  bool GetA() const { return data[0] != 0; }
  void Modify() { data[0] = 1; }
  ~Foo() { SetStatus(Status::Destructed); }
  // We test using a custom operator new/delete
  // pair partly for purposes of recording status,
  // and partly so that we can verify that moveit
  // will work for C++ classes which do similar.
  void *operator new(size_t count) {
    SetStatus(Status::Allocated);
    return ::operator new(count);
  }
  void *operator new(size_t count, void *ptr) {
    SetStatus(Status::Allocated);
    return ::operator new(count, ptr);
  }
  void operator delete(void *ptr) noexcept {
    ::operator delete(ptr);
    SetStatus(Status::Deallocated);
  }

private:
  uint32_t data[4];
};

class Bar {
public:
  Bar() {
    data[0] = 0;
    SetStatus(Status::Initialized);
  }
  ~Bar() { SetStatus(Status::Destructed); }

private:
  uint32_t data[4];
};

// Everything below here would be generated by some code generator

inline Foo *foo_create_uninitialized() { return new_appropriately<Foo>(1); }

inline void foo_free_uninitialized(Foo *foo) {
  SetStatus(Status::DeallocatedUninitialized);
  delete_appropriately<Foo>(foo);
  // This should end up calling operator delete
  // and replacing DeallocatedUninitialized with
  // Deallocated.
}

inline Bar *bar_create_uninitialized() { return new_appropriately<Bar>(1); }

inline void bar_free_uninitialized(Bar *bar) {
  SetStatus(Status::DeallocatedUninitialized);
  delete_appropriately<Bar>(bar);
}

inline void foo_constructor(Foo *foo) { new (foo) Foo(); }
inline void foo_destructor(Foo *foo) { foo->~Foo(); }
inline void foo_move(Foo *dest, Foo *src) { new (dest) Foo(std::move(*src)); }

inline void bar_constructor(Bar *bar) { new (bar) Bar(); }
inline void bar_destructor(Bar *bar) { bar->~Bar(); }
inline void bar_move(Bar *dest, Bar *src) { new (dest) Bar(std::move(*src)); }

#endif // CXX_SUPPORT_TEST_CPP